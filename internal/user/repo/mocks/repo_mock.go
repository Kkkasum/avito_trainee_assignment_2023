// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"avito_2023/internal/user/model"
	"avito_2023/internal/user/repo"
	"context"
	"sync"
	"time"
)

// Ensure, that RepoMock does implement repo.Repo.
// If this is not the case, regenerate this file with moq.
var _ repo.Repo = &RepoMock{}

// RepoMock is a mock implementation of repo.Repo.
//
//	func TestSomethingThatUsesRepo(t *testing.T) {
//
//		// make and configure a mocked repo.Repo
//		mockedRepo := &RepoMock{
//			GetUserHistoryFunc: func(ctx context.Context, userID uint, month uint, year uint) ([]*model.UserHistory, error) {
//				panic("mock out the GetUserHistory method")
//			},
//			GetUserSegmentsFunc: func(ctx context.Context, userID uint) ([]*string, error) {
//				panic("mock out the GetUserSegments method")
//			},
//			UpdateUserSegmentsFunc: func(ctx context.Context, userID uint, slugsToAdd []string, slugsToDel []string, deleteAt *time.Time) error {
//				panic("mock out the UpdateUserSegments method")
//			},
//		}
//
//		// use mockedRepo in code that requires repo.Repo
//		// and then make assertions.
//
//	}
type RepoMock struct {
	// GetUserHistoryFunc mocks the GetUserHistory method.
	GetUserHistoryFunc func(ctx context.Context, userID uint, month uint, year uint) ([]*model.UserHistory, error)

	// GetUserSegmentsFunc mocks the GetUserSegments method.
	GetUserSegmentsFunc func(ctx context.Context, userID uint) ([]*string, error)

	// UpdateUserSegmentsFunc mocks the UpdateUserSegments method.
	UpdateUserSegmentsFunc func(ctx context.Context, userID uint, slugsToAdd []string, slugsToDel []string, deleteAt *time.Time) error

	// calls tracks calls to the methods.
	calls struct {
		// GetUserHistory holds details about calls to the GetUserHistory method.
		GetUserHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uint
			// Month is the month argument value.
			Month uint
			// Year is the year argument value.
			Year uint
		}
		// GetUserSegments holds details about calls to the GetUserSegments method.
		GetUserSegments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uint
		}
		// UpdateUserSegments holds details about calls to the UpdateUserSegments method.
		UpdateUserSegments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uint
			// SlugsToAdd is the slugsToAdd argument value.
			SlugsToAdd []string
			// SlugsToDel is the slugsToDel argument value.
			SlugsToDel []string
			// DeleteAt is the deleteAt argument value.
			DeleteAt *time.Time
		}
	}
	lockGetUserHistory     sync.RWMutex
	lockGetUserSegments    sync.RWMutex
	lockUpdateUserSegments sync.RWMutex
}

// GetUserHistory calls GetUserHistoryFunc.
func (mock *RepoMock) GetUserHistory(ctx context.Context, userID uint, month uint, year uint) ([]*model.UserHistory, error) {
	if mock.GetUserHistoryFunc == nil {
		panic("RepoMock.GetUserHistoryFunc: method is nil but Repo.GetUserHistory was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uint
		Month  uint
		Year   uint
	}{
		Ctx:    ctx,
		UserID: userID,
		Month:  month,
		Year:   year,
	}
	mock.lockGetUserHistory.Lock()
	mock.calls.GetUserHistory = append(mock.calls.GetUserHistory, callInfo)
	mock.lockGetUserHistory.Unlock()
	return mock.GetUserHistoryFunc(ctx, userID, month, year)
}

// GetUserHistoryCalls gets all the calls that were made to GetUserHistory.
// Check the length with:
//
//	len(mockedRepo.GetUserHistoryCalls())
func (mock *RepoMock) GetUserHistoryCalls() []struct {
	Ctx    context.Context
	UserID uint
	Month  uint
	Year   uint
} {
	var calls []struct {
		Ctx    context.Context
		UserID uint
		Month  uint
		Year   uint
	}
	mock.lockGetUserHistory.RLock()
	calls = mock.calls.GetUserHistory
	mock.lockGetUserHistory.RUnlock()
	return calls
}

// GetUserSegments calls GetUserSegmentsFunc.
func (mock *RepoMock) GetUserSegments(ctx context.Context, userID uint) ([]*string, error) {
	if mock.GetUserSegmentsFunc == nil {
		panic("RepoMock.GetUserSegmentsFunc: method is nil but Repo.GetUserSegments was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uint
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetUserSegments.Lock()
	mock.calls.GetUserSegments = append(mock.calls.GetUserSegments, callInfo)
	mock.lockGetUserSegments.Unlock()
	return mock.GetUserSegmentsFunc(ctx, userID)
}

// GetUserSegmentsCalls gets all the calls that were made to GetUserSegments.
// Check the length with:
//
//	len(mockedRepo.GetUserSegmentsCalls())
func (mock *RepoMock) GetUserSegmentsCalls() []struct {
	Ctx    context.Context
	UserID uint
} {
	var calls []struct {
		Ctx    context.Context
		UserID uint
	}
	mock.lockGetUserSegments.RLock()
	calls = mock.calls.GetUserSegments
	mock.lockGetUserSegments.RUnlock()
	return calls
}

// UpdateUserSegments calls UpdateUserSegmentsFunc.
func (mock *RepoMock) UpdateUserSegments(ctx context.Context, userID uint, slugsToAdd []string, slugsToDel []string, deleteAt *time.Time) error {
	if mock.UpdateUserSegmentsFunc == nil {
		panic("RepoMock.UpdateUserSegmentsFunc: method is nil but Repo.UpdateUserSegments was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		UserID     uint
		SlugsToAdd []string
		SlugsToDel []string
		DeleteAt   *time.Time
	}{
		Ctx:        ctx,
		UserID:     userID,
		SlugsToAdd: slugsToAdd,
		SlugsToDel: slugsToDel,
		DeleteAt:   deleteAt,
	}
	mock.lockUpdateUserSegments.Lock()
	mock.calls.UpdateUserSegments = append(mock.calls.UpdateUserSegments, callInfo)
	mock.lockUpdateUserSegments.Unlock()
	return mock.UpdateUserSegmentsFunc(ctx, userID, slugsToAdd, slugsToDel, deleteAt)
}

// UpdateUserSegmentsCalls gets all the calls that were made to UpdateUserSegments.
// Check the length with:
//
//	len(mockedRepo.UpdateUserSegmentsCalls())
func (mock *RepoMock) UpdateUserSegmentsCalls() []struct {
	Ctx        context.Context
	UserID     uint
	SlugsToAdd []string
	SlugsToDel []string
	DeleteAt   *time.Time
} {
	var calls []struct {
		Ctx        context.Context
		UserID     uint
		SlugsToAdd []string
		SlugsToDel []string
		DeleteAt   *time.Time
	}
	mock.lockUpdateUserSegments.RLock()
	calls = mock.calls.UpdateUserSegments
	mock.lockUpdateUserSegments.RUnlock()
	return calls
}
